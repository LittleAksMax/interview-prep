# Introduction

## The Interview Process

Data structures and algorithms questions are valuable to the interviewer for testing fundamental problem
solving skills with questions that are often incredibly difficult to avoid clustering candidates in terms
of performance.

You are evaluated **relative** to other candidates, so you are most likely to find questions with many steps
that don't necessarily require special knowledge about any concepts (at least for general software
engineering) - this forces the candidates to have to utilise problem solving skills instead of just
memorisation.

A company's response might be delayed. No response != rejection (just inquire).

You can reapply after 6 months - 1 year after initial application. You may be disadvantaged past your first
two applications.

## Behind the Scenes

The most common interview process involves:
- Screening phone interview (still relatively technical)
- 3 to 6 in-person interviews

Some interviewers give homework assignments for you to do after the phone interview.

"Why do you want to work for xyz" is a common question.
- Express passion for their technology
- Get familiar with the companies products

### Microsoft

You meet the hiring manager if you've done really well.

### Amazon

Prefer questions about scalability and object-oriented/system design. This will unfortunately not be the
focus of this repository.

The 'bar raiser' is moved in from another team. They have veto power in decision and are used to make one of
the interviewers really difficult.

### Google

Prefer system design and scalability. Strong focus on analytical algorithmic questions. If you have little
work experience, you will be bullied by the data structures and algorithms questions especially.

Google has a hiring committee who rely on interviewers notes to make the decision.

### Apple

2-on-1 interviews.

They especially have employees that are passionate Apple fans. You should be familiar with a Mac system.

Usually 6-8 interviews on campus. Each interviewer will focus on a different aspects.

### Facebook

They want developers who work quickly and elegantly.

Facebook interviews for the whole company, not just a single team. After you get hired you get caught up to
speed on their projects and codebases in a 6-week bootcamp.

### Palantir

- 2 phone interviews
- HackerRank coding assignment (likely for those with less work experience)

You may be shown a demo of a Palantir product and then you are encouraged to ask questions about the product.
Ask good questions.

On average, their technical questions are up to a much higher standard.

Lots of emphasis on the efficiency of the algorithms you produce.

## Special Situations

I will only make notes on Experienced Candidates, Dev Lead/Manager, Startups and Acquisitions/Acquihires since
that's what is important for me.

### Experienced candidates

Likely to have a smaller focus on technical coding questions and a bit more on system design. This is because
they'd have worked with more large systems (compared to students for example) and would be out of practice
with the algorithms you learn at university.

Also likely to get asked questions about impressive projects you've worked on before:
- "What is the hardest bug you've faced"

### Dev Lead/Manager

Still tested for strong coding skills. Also tested on Teamwork, Prioritisation, Communication, and being able
to just 'get things done'. Depends a lot on experience and personality.

### Startups

Most often you can get opportunities through personal referral. You can even just reach out and showing
interest to someone in the company could get your resume picked up.

You should be familiar with their technologies since they want you to be able to be stuck right into the deep
end.

Regular interviewing process except stronger focus on personality/experience (Behavioural questions) and having a skill
set that is already compatible with the company.

### Acquisitions/Acquihires

These interviews can ruin the acquisition if they don't go well enough on average. It can be a screening for
the company and so change the value of the company.

Engineers at the startup that don't perform well in the interviews don't get hired to the buyer company --
sometimes they get given a short contract the buyer company for 'knowledge transfer'. CEO's are often slotted
into a product manager/lead position, since that mirrors their responsibility closest.

Often the engineers that are kept are either merged with another team in the buyer's company.

## Before the Interview

### Getting the right experience

Get internships during university.

Take modules that have large courseworks as part of them.

Use your nights and weekends for building projects, participating in Hackathons, contribute to open source.
Employers like candidates that build stuff 'just for fun' -- it shows initiative and passion for the field.

### Writing a great CV

1 page for <10 years experience, 2 pages past that.

Relevant hobbies/activities take precendence over non-relevant hobbies/activities.

Strong bullet points should highlight measurable achievements: include specific metrics:
- 'Accomplished X by implementing Y which led to Z'
- Reduced object-time rendering by 75% by implementing distributed caching, leading to a 10% reduction in
  login time.
- Increased average match accuracy from 1.2 to 1.5 by implementing a new comparison algorithm based on
  windiff.

Only include relevant work experience/projects/technologies FOR EACH APPLICATION. Projects that highlight
skills that are required for a certain role should be included over others in the limited space you have for
the CV. Try to list things like programming languages concisely:
- Java (expert), Python (fluent), C/C++ (proficient)

Don't use time as a measure of language proficiency, because it's unclear exactly how much of that time you
were actually using and actively programming in the language.

Include 2-4 'impressive' projects. The best projects solve a certain problem -- they are useful.

#### Stigmas

Some technologies/languages have stigmas against them. Apparently everything .NET is only good for jobs
where .NET is a required technology.

Don't overdo the languages you know, maybe 6 relevant ones only. But make sure it's more than 2.

Only include certifications that are impressive and relevant concepts (e.g., usage of technologies, e.g., AWS
\> certification in some programming language).

## Behavioural Questions

### Projects

For each project you mentioned in your application, you can list the:
- Challenges
- Mistakes/Failures
- What you enjoyed
- Leadership examples
- Conflicts
- What you'd do differently

This prepares you for any in-depth conversations about your projects and will make your answers seem more
fluent.

### What are your weaknesses?

**Don't be arrogant**. Say a legitimate weakness, how you've improved on it/overcome it.
- Sometimes I don't have very good attention to detail. While that's good because it lets me execute quickly,
  it also means that sometimes I make careless mistakes. Because of that, I make sure to always have someone
  else double-check my work.
- I often want my code to be perfect before it actually works. This means that I often end up in a perpetual
  refactor loop, where I keep changing the same small piece of code over and over again and it often ends up
  over-engineered. Because of that, I usually make a list of features and then a To-Do list with the series of
  tasks to get to my goal. This let's me build up to perfect code in a steady fashion.

### Questions to ask the interviewer

They come in three categories:
- Genuine - questions for valuable information that shows your interest
  - What is the ratio of developers to program managers? What is the interaction like? How does project
    planning happen on the team?
  - What brought you (the interviewer) to this company? What has been most challenging for you?
- Insightful - questions about the company's technology that demonstrate knowledge/understanding
  - I noticed you use technology X? How do you handle problem Y?
- Passion - questions that show your passion for the field
  - I'm very interested in scalability, and I'd love to learn more. What opportunities are there at this
    company to learn more about this.
  - I'm not familiar with technology X, but it sounds like an interesting solution. Could you tell me a bit
    more about how this works.

### Responding to Behavioural Questions

- Nugget -- succinct description of scenario
- Situation -- What was the problem?
- Action -- (most important, don't be brief, flesh it out)
- Result -- How did your actions solve/better the problem?

These answers should show that you have: leadership, empathy, compassion, humility, teamwork/helpfulness.

### Tell me about yourself?

- Current role (headline only)
- University and activities in university
- Post university and onwards (briefly)
- Current role (details)
- Outside of work (learning something new, project, etc.)
- Wrap up (why are you interviewing here? Why this company?)

Try to sprinkle in successes: awards/promotions/being recruited by ex-coworker/launches).

## Big O

Big O notation is used to describe algorithm efficiency. It's more a measure of how well it scales as the input increases in size, rather than the actual speed of an algorithm -- which could be dependent on a handful of factors, e.g., hardware.

### Big O vs Big Theta vs Big Omega

Worst case -- **O** describes *asymptotic runtime* -- what does the number of steps tend to? It is an upper bound on runtime. Meaning if you have something like a linear search, it is `O(N)` with N being the number of elements in the collection being searched. Likewise, the linear search is also `O(N^2)`, `O(N^3)` and any other runtime slower than and including `O(N)`.

Best case -- If **O** describes an upper bound on computation time **Ω** describes the equivalent concept for a lower bound. For the same linear search example, it's `Ω(1)` since the runtime will never be faster than a runtime of 1.

Expected case -- **θ** describes the tight bound on runtime. For the linear search example its `θ(N)` since the runtime of the average case also scales linearly with input size.

### Space complexity

How does the amount of required memory scale with the input size?

A factorial algorithm defined as:

```java
int fact(int n) {
  if (n <= 0) {
    return 1;
  }
  return n * fact(n - 1);
}
```

Would have a space complexity of `O(n)` since for any input `n`  you would have to make `n` calls to the `fact` function which occupy memory on the stack.

However, the following factorial algorithm:

```java
int fact(int n) {
  int prod = 1;
  for (int i = 1; i < n; i++) {
    prod *= i;
  }
  return prod;
}
```

Would have space complexity of `O(1)` since you would use a constant amount of memory for any input `n`.

### Dropping the non-dominant terms and constants

If the number of steps we get is something like:
- `O(N^2 + N)` -> `O(N^2)`
- `O(N + log N)` -> `O(N)`
- `O(2^N + N^100)` -> `O(2^n)`
- `O(N + P) where P < N/2` -> `O(N)` since `N` dominates `P`

This is because we only care about the scaling of the algorithm tends to (hence 'asymptotic runtime').

You can't reduce runtimes that depend on multiple variables: e.g., `O(A^2 + B)` can't be reduced.

### Amortized Time

What would be the time complexity of appending an element to a statically implemented list data structure?
- Usually it's `O(1)` to do the insertion
- What if we are at maximum capacity and we have to resize the underlying array structure first? Then we allocate memory for 2N elements and then copy N elements over

**Amortized time** takes into account a worst case that will happen time-to-time, but rarely.

After X elements, we double the capacity from `1 -> 2 -> 4 -> 8 -> ... -> X`. That doubling takes respectively, `1, 2, 4, 8, 16, ..., X` copies. So up to X adds, we take `X + X/2 + X/4 + X/8 + ... + 1` time which is approximately `2X`.

So X adds take `O(X)` time, the amortized time for adding each element is `O(1)`.

## Technical Questions

It's good practice to implement data structures and algorithms from scratch on paper, to get used to the
whiteboard interview environment and drill in the fundamentals. Especially focus on hashtables.

### Problem Solving

Pay very close to attention to **the question** details:
- are duplicates allowed
- bounds of values
- etc.
Often all the details will be required for the optimal solution.

Find **examples** to try to spot a pattern:
- Special cases
- Too small (most examples are 50% too small than useful)

**Consider possiblities**:
1. Bruteforce -- state it, explain why it's sub-optimal terrible, it's space and time complexity, and where it could possibly be optimised
2. Optimise -- sometimes a fresh example helps to spot patterns
  - unused information
  - solve incorrectly and find exactly where your algorithm fails
  - trade off space for time
  - precompute some information

Before diving into coding, ensure you fully understand your algorithm.

For the implementation, try to make the solution as **beautiful** as possible:
- Modularize code from the beginning it makes changes/refactors easier, and also allows you to skip certain functions until later.
- Mid-code tests/assertions (even a TODO tag is good)
- Clear variable names

**Test** with **edge cases**, and other **special cases**, does the algorithm still work?
- Test smaller bits of implemented functionality with smaller tests

### BUD
- Bottlenecks
  - why improve the part of the algorithm that's O(N), when the other part of it is O(N log N)
  - repeated work exists -- improve that algorithm to greatly improve efficiency
- Unnecessary work
  - Do we need to keep iterating if we have found a solution? Just break if not.
- Duplicated work
  - Won't improve on the scalability, but it can improve actual computation speed.

### Best Conceivable Runtime

The BCR can offer a really helpful hint often. If you have two array inputs to a problem (`a` and `b`), you must have to at least touch each element in each array to ensure that you have found the most optimal solution. So the BCR is `O(A + B)`.

The BCR is useful because it gives us a loose lower bound that we can't possibly do any better than, and we can work up from. As a result, if you need to do some precomputation, any of it done in less than the BCR runtime is essentially 'free' since it won't impact runtime.

BCR also tells us when we are done optimising our algorithm for runtime, and can move onto optimising for space.

If we manage to reach BCR runtime and `O(1)` additional space, we are completely done. Note that this may not be possible.

### Good code

- Correct -- it works as it should under the problem specification
- Efficient -- it works as efficiently as possible with space and time in mind
- Simple -- concise
- Readable -- well-commented, fancy code should be pointed out and appropriately explained
- Maintainable -- Adaptable

It's good to use data structures generously. They are there to be used. If you can use an array instead of 5 separate values, use an array. Maybe you can even make a separate class for the inputs if it is useful.

Ensure that your code is **modular** enough to allow for **appropriate code reuse**. Modularity also ensures that you don't have to implement everything as you figure out the algorithm, you can also just use a declared function and implement it later after you write the 'meaty' parts of the algorithm.

Ensure that your code is flexible and robust. Generalising a problem to a structure with dimensions `N` is more impressive than hard-coding something where `N = 3`.

Ensure that you check your code as you write it. Sprinkling in `assert` statements is a nice way to make inline checks happen.

## The Offer and Beyond

### Handling rejections and declining offers

Most offers have acceptance deadlines; if that isn't enough time (waiting for other offers) you can ask for an extension. This will usually be accomodated.

If you decline an offer, decline on good terms and keep the line of communication open. Make the decline with a reason that is **non-offensive** and **inarguable**.
- Reject a big company by saying you think a startup is the right choice for you at the moment.

When getting a rejection, explain that you are disappointed but understand the company's position. Ask when you can reapply, and for feedback on the interviews (what could I work on for next time?).

### Evaluating an offer
- Financial package is worth clearing up (Signing bonus + relocation, cost-of-living differences, average annual bonus, stock options and grants)
- Career development -- you are likely to keep moving after a couple years
  - How good does the company look on your resume?
  - Will you develop relevant skills? Promotion plan?
  - Will this company aid in your move into management? Does the company offer a realistic plan?
  - Is the company/team growing?
  - If I want to leave, is the company based near other potential company's?
- Company stability
- Happiness Factor

### Negotiation

- Just do it -- recruiters can't reject offers just because you negotiated
- Viable alternatives -- you are more likely to be able to negotiate if you have other opportunities lined up that a company needs to compete with
- Always have something you are gunning for -- specific demands are more likely to be met in your favour
- Overshoot to start -- this way when the company meets you in the middle, you will still be satisfied
- Not just salary -- stocks, maybe something more immediate is required, if you get given cash for relocation, then you may have some money spare
- Do it over email if you are not as confident over the phone.

### On the job
- Set a timeline for what you want to achieve at the job and in the next ten years
- Build strong relationships with manager and teammates, personal acquaintances could offer better job prospects
- Ask for what you want -- perhaps a project with a more backend focus
- Keep interviewing